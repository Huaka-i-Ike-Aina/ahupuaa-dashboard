---
title: "Data Processing Notebook"
format: html
---

```{r setup-install, include=FALSE}

packages <- c("leaflet", "sf", "dplyr", "knitr", "jsonlite", "purrr")

install_if_missing <- function(pkg) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    install.packages(pkg, repos='http://cran.us.r-project.org')
  }
}

invisible(lapply(packages, install_if_missing))
invisible(lapply(packages, library, character.only = TRUE))

knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

```{r setup-folders, include=FALSE}
dir.create("processed_data", showWarnings = FALSE)
dir.create("processed_data/mokupuni_data", showWarnings = FALSE)
dir.create("processed_data/moku_data", showWarnings = FALSE)
dir.create("processed_data/ahupuaa_data", showWarnings = FALSE)

```


```{r ahupuaa-merge-processing}
raw_ahupuaa_data <- st_read("raw_data/Ahupuaa.geojson")

merged_polygons <- raw_ahupuaa_data %>%
  group_by(ahupuaa, moku, mokupuni) %>% # add all columns you want to match
  summarise(geometry = st_union(geometry), .groups = 'drop')


st_write(
  merged_polygons,
  "processed_data/merged_ahupuaa.geojson",
  delete_dsn = TRUE
)


merged_originals <- raw_ahupuaa_data %>%
  group_by(ahupuaa, moku, mokupuni) %>% # add all columns you want to match
  filter(n() > 1) %>% # only keep groups with multiple polygons
  ungroup()

st_write(
  merged_originals,
  "processed_data/merged_originals.geojson",
  delete_dsn = TRUE
)

```


```{r one-time-ahupuaa-hierarchy}
# Function to create hierarchical structure from Ahupua'a data
create_ahupuaa_hierarchy <- function(geojson_data) {
  # Extract the data frame (removing geometry for processing)
  df <- st_drop_geometry(geojson_data)

  # Clean and standardize the data
  df <- df %>%
    select(mokupuni, moku, ahupuaa) %>%
    # Remove any rows with missing values
    filter(!is.na(mokupuni) & !is.na(moku) & !is.na(ahupuaa)) %>%
    # Remove duplicates
    distinct() %>%
    # Sort for consistent ordering
    arrange(mokupuni, moku, ahupuaa)

  # Create unique value lists
  unique_values <- list(
    mokupuni = sort(unique(df$mokupuni)),
    moku = sort(unique(df$moku)),
    ahupuaa = sort(unique(df$ahupuaa))
  )

  # Create hierarchical structure
  hierarchy <- list()

  for (island in unique_values$mokupuni) {
    island_data <- df[df$mokupuni == island, ]
    island_moku <- list()

    for (district in unique(island_data$moku)) {
      district_data <- island_data[island_data$moku == district, ]
      district_ahupuaa <- sort(unique(district_data$ahupuaa))

      island_moku[[district]] <- list(
        name = district,
        ahupuaa = district_ahupuaa,
        ahupuaa_count = length(district_ahupuaa)
      )
    }

    hierarchy[[island]] <- list(
      name = island,
      moku = island_moku,
      moku_count = length(island_moku),
      total_ahupuaa = sum(sapply(island_moku, function(x) x$ahupuaa_count))
    )
  }

  # Create summary statistics
  summary_stats <- list(
    total_mokupuni = length(unique_values$mokupuni),
    total_moku = length(unique_values$moku),
    total_ahupuaa = length(unique_values$ahupuaa),
    mokupuni_details = sapply(
      names(hierarchy),
      function(island) {
        list(
          name = island,
          moku_count = hierarchy[[island]]$moku_count,
          ahupuaa_count = hierarchy[[island]]$total_ahupuaa
        )
      },
      simplify = FALSE
    )
  )

  # Return comprehensive structure
  result <- list(
    hierarchy = hierarchy,
    unique_values = unique_values,
    summary = summary_stats,
    flat_structure = df
  )

  return(result)
}

# Function to export hierarchy to JSON file
export_hierarchy_json <- function(
  hierarchy_result,
  filename = "ahupuaa_hierarchy.json"
) {
  jsonlite::write_json(
    hierarchy_result,
    filename,
    pretty = TRUE,
    auto_unbox = TRUE
  )
  cat("Hierarchy exported to:", filename, "\n")
}

# Function to print hierarchy in a readable format
print_hierarchy <- function(hierarchy_result, max_ahupuaa_display = 5) {
  cat("=== AHUPUA'A HIERARCHICAL STRUCTURE ===\n\n")

  # Print summary
  cat("SUMMARY:\n")
  cat(
    "- Total Mokupuni (Islands):",
    hierarchy_result$summary$total_mokupuni,
    "\n"
  )
  cat("- Total Moku (Districts):", hierarchy_result$summary$total_moku, "\n")
  cat("- Total Ahupua'a:", hierarchy_result$summary$total_ahupuaa, "\n\n")

  # Print detailed hierarchy
  for (island_name in names(hierarchy_result$hierarchy)) {
    island <- hierarchy_result$hierarchy[[island_name]]
    cat(
      "ðŸï¸ ",
      island_name,
      " (",
      island$moku_count,
      " moku, ",
      island$total_ahupuaa,
      " ahupua'a)\n",
      sep = ""
    )

    for (moku_name in names(island$moku)) {
      moku <- island$moku[[moku_name]]
      cat(
        "  ðŸ“ ",
        moku_name,
        " (",
        moku$ahupuaa_count,
        " ahupua'a)\n",
        sep = ""
      )

      # Display first few ahupua'a
      ahupuaa_to_show <- head(moku$ahupuaa, max_ahupuaa_display)
      for (ahupuaa in ahupuaa_to_show) {
        cat("    - ", ahupuaa, "\n", sep = "")
      }

      # Show ellipsis if there are more
      if (length(moku$ahupuaa) > max_ahupuaa_display) {
        cat("    ... and", length(moku$ahupuaa) - max_ahupuaa_display, "more\n")
      }
      cat("\n")
    }
  }
}

# Function to create a simple lookup table
create_lookup_table <- function(hierarchy_result) {
  lookup <- hierarchy_result$flat_structure %>%
    mutate(
      full_path = paste(mokupuni, moku, ahupuaa, sep = " > "),
      id = paste(mokupuni, moku, ahupuaa, sep = "_")
    ) %>%
    select(id, full_path, mokupuni, moku, ahupuaa)

  return(lookup)
}

# Function to search within the hierarchy
search_hierarchy <- function(
  hierarchy_result,
  search_term,
  case_sensitive = FALSE
) {
  df <- hierarchy_result$flat_structure

  if (!case_sensitive) {
    search_term <- tolower(search_term)
    search_df <- df %>%
      mutate(
        mokupuni_lower = tolower(mokupuni),
        moku_lower = tolower(moku),
        ahupuaa_lower = tolower(ahupuaa)
      )

    results <- search_df %>%
      filter(
        grepl(search_term, mokupuni_lower) |
          grepl(search_term, moku_lower) |
          grepl(search_term, ahupuaa_lower)
      ) %>%
      select(mokupuni, moku, ahupuaa)
  } else {
    results <- df %>%
      filter(
        grepl(search_term, mokupuni) |
          grepl(search_term, moku) |
          grepl(search_term, ahupuaa)
      )
  }

  return(results)
}


# Function to create dropdown/select options for UI components
create_ui_options <- function(hierarchy_result) {
  # For mokupuni dropdown
  mokupuni_options <- data.frame(
    value = hierarchy_result$unique_values$mokupuni,
    label = hierarchy_result$unique_values$mokupuni,
    stringsAsFactors = FALSE
  )

  # For moku dropdown (will need to be filtered based on mokupuni selection)
  moku_options <- hierarchy_result$flat_structure %>%
    select(mokupuni, moku) %>%
    distinct() %>%
    arrange(mokupuni, moku)

  # For ahupuaa dropdown (will need to be filtered based on moku selection)
  ahupuaa_options <- hierarchy_result$flat_structure %>%
    select(mokupuni, moku, ahupuaa) %>%
    distinct() %>%
    arrange(mokupuni, moku, ahupuaa)

  return(list(
    mokupuni = mokupuni_options,
    moku = moku_options,
    ahupuaa = ahupuaa_options
  ))
}

# Display usage instructions
cat("=== AHUPUA'A HIERARCHY CREATOR ===\n")
cat("Functions available:\n")
cat("1. create_ahupuaa_hierarchy(geojson_data) - Main function\n")
cat("2. print_hierarchy(result) - Display hierarchy\n")
cat("3. export_hierarchy_json(result, filename) - Export to JSON\n")
cat("4. create_lookup_table(result) - Create simple lookup\n")
cat("5. search_hierarchy(result, term) - Search functionality\n")
cat("6. create_ui_options(result) - Create UI dropdown options\n")
cat("7. example_usage() - Show example code\n\n")
cat("Run example_usage() to see how to use these functions!\n")

# Load your data
ahupuaa_data <- st_read("raw_data/Ahupuaa.geojson")

# Create hierarchy
hierarchy_result <- create_ahupuaa_hierarchy(ahupuaa_data)

# Access unique values (for dashboard filters)
unique_islands <- hierarchy_result$unique_values$mokupuni
unique_districts <- hierarchy_result$unique_values$moku
unique_ahupuaa <- hierarchy_result$unique_values$ahupuaa

# Access hierarchical structure (for nested navigation)
oahu_districts <- names(hierarchy_result$hierarchy[["OÊ»ahu"]]$moku)
honolulu_ahupuaa <- hierarchy_result$hierarchy[["OÊ»ahu"]]$moku[[
  "Honolulu"
]]$ahupuaa

ui_options <- create_ui_options(hierarchy_result)
export_hierarchy_json(hierarchy_result, 'processed_data/ahupuaa_hierarchy.json')
ui_options

```


```{r one-time-moku-processing}
raw_moku_data <- st_read("raw_data/Moku_Ridge_To_Reef_(DAR).geojson")


merged_mokupuni <- raw_ahupuaa_data %>%
  group_by(mokupuni) %>% # add all columns you want to match
  summarise(geometry = st_union(geometry), .groups = 'drop')


merged_mokupuni_ridge_to_reef <- raw_moku_data %>%
  group_by(mokupuni) %>% # add all columns you want to match
  summarise(geometry = st_union(geometry), .groups = 'drop')

st_write(
  merged_mokupuni,
  "processed_data/merged_mokupuni.geojson",
  delete_dsn = TRUE
)

st_write(
  merged_mokupuni_ridge_to_reef,
  "processed_data/merged_mokupuni_ridge_to_reef.geojson",
  delete_dsn = TRUE
)

```


```{r carbon-assessment-counts}

raw_carbon_data <- st_read(
  "raw_data/Carbon_Assessment_of_Hawaii_-_Land_Cover_-_Biome_Unit.geojson"
)
# Create a summary of unique values per column
library(purrr)

unique_counts <- raw_carbon_data %>%
  st_drop_geometry() %>%
  select(where(is.character)) %>%
  map(
    ~ as.data.frame(table(.x)) %>%
      arrange(desc(Freq))
  ) # sorted by frequency

unique_counts
```

```{r carbon-assessment-merge-mokupuni}
carbon_polygons <- st_read(
  "raw_data/Carbon_Assessment_of_Hawaii_-_Land_Cover_-_Biome_Unit.geojson"
)

merged_mokupuni <- st_read(
  "processed_data/merged_mokupuni_ridge_to_reef.geojson"
)


# Spatial join to assign each parcel to a district
polygons_within_mokupuni <- st_join(
  carbon_polygons,
  merged_mokupuni,
  join = st_intersects
)

# Separate by district
mokupuni_names <- unique(polygons_within_mokupuni$mokupuni)


for (mokupuni_name in mokupuni_names) {
  if (!is.na(mokupuni_name) && mokupuni_name != "") {
    mokupuni_polygons <- polygons_within_mokupuni %>%
      filter(mokupuni == mokupuni_name)

    st_write(
      mokupuni_polygons,
      paste0(
        "processed_data/mokupuni_data/carbon_polygons_",
        mokupuni_name,
        ".geojson"
      ),
      delete_dsn = TRUE
    )
  }
}

# Parcels not in any district
polygons_unassigned <- polygons_within_mokupuni %>%
  filter(is.na(mokupuni))

st_write(
  polygons_unassigned,
  "processed_data/mokupuni_data/carbon_polygons_unassigned.geojson",
  delete_dsn = TRUE
)

```

```{r carbon-assessment-merge-moku}

moku_data <- st_read("raw_data/Moku_Ridge_To_Reef_(DAR).geojson")
hierarchy_data <- fromJSON(
  "processed_data/ahupuaa_hierarchy.json"
)

ahupuaa_data <- st_read("processed_data/merged_ahupuaa.geojson")

# for each mokupuni, separate by moku
# need to maintain both mokupuni and moku columns and names to be able to filter properly
for (mokupuni_name in mokupuni_names) {
  mokupuni_polygons <- polygons_within_mokupuni %>%
    filter(mokupuni == mokupuni_name)

  # Spatial join to assign each parcel to a district
  polygons_within_moku <- st_join(
    mokupuni_polygons,
    moku_data,
    join = st_intersects,
    suffix = c("", "_moku")
  )
  # polygons_within_moku

  moku_names <- unique(polygons_within_moku$moku)

  for (moku_name in moku_names) {
    if (!is.na(moku_name) && moku_name != "") {
      moku_polygons <- polygons_within_moku %>%
        filter(moku == moku_name)

      clipped_moku_polygons <- st_intersection(
        moku_polygons,
        moku_data %>% filter(mokupuni == mokupuni_name, moku == moku_name)
      )
      st_write(
        clipped_moku_polygons,
        paste0(
          "processed_data/moku_data/carbon_polygons_",
          gsub(" ", "_", mokupuni_name),
          "_",
          gsub(" ", "_", moku_name),
          ".geojson"
        ),
        delete_dsn = TRUE
      )

      ahupuaa_names <- hierarchy_data$hierarchy[[mokupuni_name]]$moku[[
        moku_name
      ]]$ahupuaa

      for (ahupuaa_name in ahupuaa_names) {
        ahupuaa_polygons <- st_intersection(
          clipped_moku_polygons,
          ahupuaa_data %>%
            filter(
              mokupuni == mokupuni_name,
              moku == moku_name,
              ahupuaa == ahupuaa_name
            )
        )
        print(moku_name)
        print(ahupuaa_name)
        if (grepl("/", ahupuaa_name)) {
          ahupuaa_name <- gsub("/", "-", ahupuaa_name)
        }

        if (nrow(ahupuaa_polygons) > 0) {
          st_write(
            ahupuaa_polygons,
            paste0(
              "processed_data/ahupuaa_data/carbon_polygons_",
              gsub(" ", "_", mokupuni_name),
              "_",
              gsub(" ", "_", moku_name),
              "_",
              gsub(" ", "_", ahupuaa_name),
              ".geojson"
            ),
            delete_dsn = TRUE
          )
        }
      }
    }
  }
}
```
